plugins {
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "1.7-SNAPSHOT" apply false
    id "com.github.johnrengelman.shadow" version "8.1.1" apply false
    id "systems.manifold.manifold-gradle-plugin" version "0.0.2-alpha"
    id "me.modmuss50.mod-publish-plugin" version "0.5.1"
    id "io.github.pacifistmc.forgix" version "1.2.9"
}

def writeBuildGradlePredefine(List<String> AvailableVersion, int versionIndex) {
    StringBuilder sb = new StringBuilder()

    sb.append("# DON'T TOUCH THIS FILE, This is handled by the build script\n")

    for (int i = 0; i < AvailableVersion.size(); i++) {
        String versionString = AvailableVersion[i].replace(".", "_")
        sb.append("MC_" + versionString + "=" + i.toString() + "\n")

        if (versionIndex == i)
            sb.append("MC_VER=" + i.toString() + "\n")
    }

    new File(projectDir, "build.properties").text = sb.toString()
}

project.gradle.ext.getProperties().each { prop ->
    rootProject.ext.set(prop.key, prop.value)
}

writeBuildGradlePredefine(rootProject.availableVersions, rootProject.versionIndex)

version = "${rootProject.mod_version}-${rootProject.minecraft_version}"

forgix {
    group = "${rootProject.maven_group}.${rootProject.archives_name}"
    mergedJarName = "${rootProject.archives_name}-${rootProject.version}.jar"
    outputDir = "build/libs/merged"

    custom {
        projectName = "common"
        jarLocation = "build/libs/${rootProject.archives_name}-common-${rootProject.version}.jar"
    }

    fabric {
        jarLocation = "build/libs/${rootProject.archives_name}-fabric-${rootProject.version}.jar"
    }

    forge {
        jarLocation = "build/libs/${rootProject.archives_name}-forge-${rootProject.version}.jar"
    }

    neoforge {
        jarLocation = "build/libs/${rootProject.archives_name}-neoforge-${rootProject.version}.jar"
    }

    removeDuplicate "${rootProject.maven_group}.${rootProject.archives_name}"
}

architectury {
    minecraft = rootProject.minecraft_version
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.version
}

subprojects {
    apply plugin: "com.github.johnrengelman.shadow"
    apply plugin: "dev.architectury.loom"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    build.finalizedBy(mergeJars)
    assemble.finalizedBy(mergeJars)

    project.ext.addMod = { param, String path ->
        switch(param as int){
            case 1:
                project.dependencies {
                    add('modCompileOnly', path)
                }
                break
            case 2:
                project.dependencies {
                    add('modImplementation', path)
                }
                break
            default:
                println("Invalid Parameter")
        }
    }

    project.ext.addModApi = { param, String path ->
        switch(param as int){
            case 1:
                project.dependencies {
                    add('modCompileOnlyApi', path)
                }
                break
            case 2:
                project.dependencies {
                    add('modApi', path)
                }
                break
            default:
                println("Invalid Parameter")
        }
    }

    base {
        archivesName = "${rootProject.archives_name}-${project.name}"
    }

    repositories {
        maven {
            name = "ParchmentMC"
            url = "https://maven.parchmentmc.org"
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven"
                }
            }
            filter {
                includeGroup "maven.modrinth"
            }
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        mappings loom.layered() {
            officialMojangMappings()
            parchment "org.parchmentmc.data:parchment-${rootProject.parchment_version}@zip"
        }

        annotationProcessor("systems.manifold:manifold-preprocessor:${rootProject.manifold_version}")

        if (rootProject.hasProperty("embed_joml") && rootProject.embed_joml == "true" && project != project(":common"))
            include(implementation("org.joml:joml:${rootProject.joml_version}"))
        else
            implementation("org.joml:joml:${rootProject.joml_version}")
    }

    processResources {
        def replaceProperties = [
                java_version: rootProject.java_version,
                version: rootProject.mod_version,
                id: rootProject.archives_name,
                name: rootProject.mod_name,
                description: rootProject.mod_description,

                compatible_fabricmc_versions: rootProject.compatible_fabricmc_versions,
                compatible_forgemc_versions: rootProject.compatible_forgemc_versions
        ]

        inputs.properties replaceProperties
        filesMatching(["fabric.mod.json", "META-INF/mods.toml", "META-INF/neoforge.mods.toml"]) {
            expand replaceProperties
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = "UTF-8"
        options.release = rootProject.java_version as Integer
        options.compilerArgs += ["-Xplugin:Manifold"]
    }

    java {
        withSourcesJar()
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                groupId = rootProject.maven_group
                artifactId = "${rootProject.archives_name}-${project.name}"
                version = rootProject.version
                from components.java
            }
        }

        repositories {
        }
    }
}

publishMods {
    var using_ranged_game_version = rootProject.hasProperty("latest_supported_game_version")
    var is_fabric_publishing_enabled =  Boolean.parseBoolean(rootProject.enable_fabric_publishing)
    var is_forge_publishing_enabled =  Boolean.parseBoolean(rootProject.enable_forge_publishing)
    var is_neoforge_publishing_enabled =  Boolean.parseBoolean(rootProject.enable_neoforge_publishing)

    dryRun = Boolean.parseBoolean(rootProject.is_dry_run)

    version = rootProject.mod_version
    type = BETA
    changelog = rootProject.file("Changelog.md").text

    var supported_version_str = using_ranged_game_version ?
            "${rootProject.supported_game_version}-${rootProject.latest_supported_game_version}" :
            rootProject.supported_game_version

    discord {
        webhookUrl = providers.environmentVariable("DISCORD_WEBHOOK")
        dryRunWebhookUrl = providers.environmentVariable("DISCORD_WEBHOOK_DRY_RUN")
        username = "Mod Release"
        avatarUrl = "https://avatars.githubusercontent.com/u/70108603?v=4"
        content = changelog.map { "# PandaLib ${rootProject.mod_version} Release for ${supported_version_str} \n" + it}
    }

    def curseforgeOptions = curseforgeOptions {
        accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
        projectId = "975460"

        if (using_ranged_game_version)
            minecraftVersionRange {
                start = rootProject.supported_game_version
                end = rootProject.latest_supported_game_version
            }
        else
            minecraftVersions.add(rootProject.supported_game_version)

        javaVersions.add(JavaVersion.VERSION_21)

        clientRequired = true
        serverRequired = true

        projectSlug = "pandalib"

        requires("architectury-api")
    }

    def modrinthOptions = modrinthOptions {
        accessToken = providers.environmentVariable("MODRINTH_API_KEY")
        projectId = "mEEGbEIu"

        if (using_ranged_game_version)
            minecraftVersionRange {
                start = rootProject.supported_game_version
                end = rootProject.latest_supported_game_version
            }
        else
            minecraftVersions.add(rootProject.supported_game_version)

        requires("architectury-api")
    }

    def fabricOptions = publishOptions {
        file = project(":fabric").remapJar.archiveFile
        modLoaders.add("fabric")
        displayName = "[Fabric ${supported_version_str}] ${rootProject.mod_version}"
    }

    def forgeOptions = publishOptions {
        file = project(":forge").remapJar.archiveFile
        modLoaders.add("forge")
        displayName = "[Forge ${supported_version_str}] ${rootProject.mod_version}"
    }

    def neoForgeOptions = publishOptions {
        file = project(":neoforge").remapJar.archiveFile
        modLoaders.add("neoforge")
        displayName = "[NeoForge ${supported_version_str}] ${rootProject.mod_version}"
    }

    if (findProject(":fabric") && is_fabric_publishing_enabled) {
        curseforge("curseforgeFabric") {
            from(curseforgeOptions, fabricOptions)

            announcementTitle = "Download for Fabric ${supported_version_str} from CurseForge"

            requires("fabric-api")
        }

        modrinth("modrinthFabric") {
            from(modrinthOptions, fabricOptions)

            announcementTitle = "Download for Fabric ${supported_version_str} from Modrinth"

            requires("fabric-api")
        }
    }

    if (findProject(":forge") && is_forge_publishing_enabled) {
        curseforge("curseforgeForge") {
            from(curseforgeOptions, forgeOptions)

            announcementTitle = "Download for Forge ${supported_version_str} from CurseForge"
        }

        modrinth("modrinthForge") {
            from(modrinthOptions, forgeOptions)

            announcementTitle = "Download for Forge ${supported_version_str} from Modrinth"
        }
    }

    if (findProject(":neoforge") && is_neoforge_publishing_enabled) {
        curseforge("curseforgeNeoForge") {
            from(curseforgeOptions, neoForgeOptions)

            announcementTitle = "Download for NeoForge ${supported_version_str} from CurseForge"
        }

        modrinth("modrinthNeoForge") {
            from(modrinthOptions, neoForgeOptions)

            announcementTitle = "Download for NeoForge ${supported_version_str} from Modrinth"
        }
    }

    github {
        accessToken = providers.environmentVariable("GITHUB_API_KEY")
        repository = "PandaDap2006/PandaLib"
        commitish = "main"
        tagName = "release/${rootProject.mod_version}-${supported_version_str}"

        modLoaders.addAll("fabric", "forge", "neoforge")
        file = project(":common").remapJar.archiveFile

        if (findProject(":fabric"))
            additionalFiles.from(project(":fabric").remapJar.archiveFile)
        if (findProject(":forge"))
            additionalFiles.from(project(":forge").remapJar.archiveFile)
        if (findProject(":neoforge"))
            additionalFiles.from(project(":neoforge").remapJar.archiveFile)
    }
}